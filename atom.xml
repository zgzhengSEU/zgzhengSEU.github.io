<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>薛定谔的加菲猫</title>
  
  <subtitle>来一来看一看嘛</subtitle>
  <link href="https://zgzheng.top/atom.xml" rel="self"/>
  
  <link href="https://zgzheng.top/"/>
  <updated>2021-10-26T13:08:43.739Z</updated>
  <id>https://zgzheng.top/</id>
  
  <author>
    <name>SEUGarfield</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《工程矩阵》资源汇总</title>
    <link href="https://zgzheng.top/2021/10/25/%E3%80%8A%E5%B7%A5%E7%A8%8B%E7%9F%A9%E9%98%B5%E3%80%8B%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <id>https://zgzheng.top/2021/10/25/%E3%80%8A%E5%B7%A5%E7%A8%8B%E7%9F%A9%E9%98%B5%E3%80%8B%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</id>
    <published>2021-10-25T09:31:29.000Z</published>
    <updated>2021-10-26T13:08:43.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="东南大学工程矩阵视频">东南大学工程矩阵视频</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=887157521&bvid=BV1fK4y1K7Ew&cid=310389287&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div><h3 id="东南大学工程矩阵课堂板书">东南大学工程矩阵课堂板书</h3><div class="row">    <embed src="https://onedrive.live.com/embed?cid=215AF6BEFA849D0C&amp;resid=215AF6BEFA849D0C%218414&amp;authkey=AC56rDYcVEMaZPA&amp;em=2" width="100%" height="550" type="application/pdf"></div><h3 id="东南大学工程矩阵习题讲解">东南大学工程矩阵习题讲解</h3><div class="row">    <embed src="https://onedrive.live.com/embed?cid=215AF6BEFA849D0C&amp;resid=215AF6BEFA849D0C%218413&amp;authkey=AO6Hv3HfsetAmLc&amp;em=2" width="100%" height="550" type="application/pdf"></div><h3 id="东南大学工程矩阵近十年试卷">东南大学工程矩阵近十年试卷</h3><div class="row">    <embed src="https://onedrive.live.com/embed?cid=215AF6BEFA849D0C&amp;resid=215AF6BEFA849D0C%218412&amp;authkey=AHvDJM7RQObjhdY&amp;em=2" width="100%" height="550" type="application/pdf"></div><h3 id="东南大学工程矩阵模拟题12套">东南大学工程矩阵模拟题12套</h3><div class="row">    <embed src="https://onedrive.live.com/embed?cid=215AF6BEFA849D0C&amp;resid=215AF6BEFA849D0C%218410&amp;authkey=AEdNue8SnYvzuyA&amp;em=2" width="100%" height="550" type="application/pdf"></div><h3 id="东南大学工程矩阵历年试题解答">东南大学工程矩阵历年试题解答</h3><div class="row">    <embed src="https://onedrive.live.com/embed?cid=215AF6BEFA849D0C&amp;resid=215AF6BEFA849D0C%218411&amp;authkey=AJFCHZstxMA8s20&amp;em=2" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="工程矩阵" scheme="https://zgzheng.top/tags/%E5%B7%A5%E7%A8%8B%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>关于枚举去重</title>
    <link href="https://zgzheng.top/2021/10/25/%E5%85%B3%E4%BA%8E%E6%9E%9A%E4%B8%BE%E5%8E%BB%E9%87%8D/"/>
    <id>https://zgzheng.top/2021/10/25/%E5%85%B3%E4%BA%8E%E6%9E%9A%E4%B8%BE%E5%8E%BB%E9%87%8D/</id>
    <published>2021-10-25T05:59:28.000Z</published>
    <updated>2021-10-25T06:08:17.597Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="四数之和"><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h3><p>Difficulty: <strong>中等</strong></p><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> ：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></li><li>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></li></ul><h4 id="solution">Solution</h4><p>Language: cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//排序，保证相同的数位置相邻</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//遍历放在第一个位置的数，相同的数选第一个，后面的跳过</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//遍历放在第二个位置的数，相同的数选第一个，后面的跳过</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>, u = nums.<span class="built_in">size</span>() - <span class="number">1</span>; k &lt; u; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; j + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//遍历放在第三个位置的数，相同的数选第一个，后面的跳过</span></span><br><span class="line">                    <span class="keyword">while</span> (u - <span class="number">1</span> &gt; k &amp;&amp; nums[i] + nums[j] &gt;= target - nums[k] - nums[u - <span class="number">1</span>]) --u;<span class="comment">//遍历放在第一个位置的数，要选择满足条件的最前面的数，从左往右的第一个数</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] == target - nums[k] - nums[u]) &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k], nums[u]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="全排列-ii"><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h4 id="solution-1">Solution</h4><p>Language: c++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//排序，保证相同的数位置相邻</span></span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        used = vector&lt;<span class="keyword">bool</span>&gt;(n);</span><br><span class="line">        path = vector&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//选择从左往右第一个未被填过的数字</span></span><br><span class="line">                <span class="comment">//如果used[i - 1] == false，说明第 i - 1 个数未被使用，故当前遍历的第 i 个数不是从左到右第一个未被填过的数，要跳过</span></span><br><span class="line">                path[u] = nums[i];</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>, nums);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://zgzheng.top/categories/LeetCode/"/>
    
    
    <category term="去重" scheme="https://zgzheng.top/tags/%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>原地哈希</title>
    <link href="https://zgzheng.top/2021/10/20/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/"/>
    <id>https://zgzheng.top/2021/10/20/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/</id>
    <published>2021-10-20T07:34:40.000Z</published>
    <updated>2021-10-21T03:54:05.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="缺失的第一个正数"><a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></h2><p>Difficulty: <strong>困难</strong></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 10&lt;sup&gt;5&lt;/sup&gt;</code></li><li><code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= nums[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li></ul><h3 id="solution">Solution</h3><h3 id="前言">前言</h3><p>如果本题没有额外的时空复杂度要求，那么就很容易实现：</p><ul><li><p>我们可以将数组所有的数放入哈希表，随后从 1 开始依次枚举正整数，并判断其是否在哈希表中;</p></li><li><p>我们可以从 1 开始依次枚举正整数，并遍历数组，判断其是否在数组中。</p></li></ul><p>如果数组的长度为 <span class="math inline">\(N\)</span>, 那么第一种做法的时间复杂度为 <span class="math inline">\(O(N)\)</span> ，空间复杂度为 <span class="math inline">\(O(N)\)</span>; 第二种做法的时间复杂度为 <span class="math inline">\(O\left(N^{2}\right)\)</span> ， 空间复杂度为 <span class="math inline">\(O(1)\)</span> 。但它们都不满足时间复杂度为 <span class="math inline">\(O(N)\)</span> 且空间复杂度为 <span class="math inline">\(O(1)\)</span> 。</p><p>「真正」满足时间复杂度为 <span class="math inline">\(O(N)\)</span> 且空间复杂度为 <span class="math inline">\(O(1)\)</span> 的算法是不存在的，但是我们可以退而求其次：利用给定数组中的空间来存储一些状态。</p><p>也就是说，如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法;</p><p>但如果我们可以修改给定的数组，那么是存在满足要求的算法的。</p><h4 id="原地哈希映射">原地哈希映射</h4><ul><li>由于题目要求我们「只能使用常数级别的空间」，而要找的数一定在 <span class="math inline">\([1, \mathrm{~N}+1]\)</span> 左闭右闭（这里 <span class="math inline">\(\mathrm{N}\)</span> 是数组的长度) 这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，<strong>哈希表其实本身也是一个数组</strong>;</li><li>我们要找的数就在 <span class="math inline">\([1, N+1]\)</span> 里，最后 <span class="math inline">\(N+1\)</span> 这个元素我们不用找。因为在前面的 <span class="math inline">\(\mathrm{N}\)</span> 个元素都找 不到的情况下，我们才返回 <span class="math inline">\(\mathrm{N}+1\)</span>;</li><li>那么，我们可以采取这样的思路：就把 1 这个数放到下标为 0 的位置， 2 这个数放到下标为 1 的位 置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个 数，就是我们要找的缺失的第一个正数。</li><li>这个思想就相当于我们自己编写<strong>哈希函数</strong>，这个哈希函数的规则特别简单，那就是数值为 <span class="math inline">\(i\)</span> 的数映射 到下标为 <span class="math inline">\(i-1\)</span> 的位置。</li></ul><p>Language: c++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != i + <span class="number">1</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="原地数组标记">原地数组标记</h4><p><strong>要标记的数据是 <span class="math inline">\(1\cdots n\)</span> ，而数组可供存储的空间下标是 <span class="math inline">\(0\cdots n-1\)</span> ，所以值为 <span class="math inline">\(i\)</span> 的数要用下标 <span class="math inline">\(i-1\)</span> 的位置空间来存储标记</strong></p><blockquote><p>我们对数组进行遍历，对于遍历到的数 <span class="math inline">\(x\)</span>, 如果它在 <span class="math inline">\([1, N]\)</span> 的范围内，那么就将数组中的第 <span class="math inline">\(x-1\)</span> 个位 置（注意：数组下标从 0 开始) 打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那 么答案是 <span class="math inline">\(N+1\)</span>, 否则答案是最小的没有打上标记的位置加 <span class="math inline">\(1\)</span>。</p></blockquote><p>那么如何设计这个「标记」呢? 由于数组中的数没有任何限制，因此这并不是一件容易的事情。但我们可以 继续利用上面的提到的性质：由于我们只在意 <span class="math inline">\([1, N]\)</span> 中的数，因此我们可以先对数组进行遍历，把不在 <span class="math inline">\([1, N]\)</span> 范围内的数修改成任意一个大于 <span class="math inline">\(N\)</span> 的数（例如 <span class="math inline">\(N+1)\)</span> 。这样一来，数组中的所有数就都是正数了， 因此我们就可以将「标记」表示为「负号」。</p><p>算法的流程如下：</p><ul><li><p>我们将数组中所有小于等于 0 的数修改为 <span class="math inline">\(N+1\)</span>;</p></li><li><p>我们遍历数组中的每一个数 <span class="math inline">\(x\)</span>, 它可能已经被打了标记，因此原本对应的数为 <span class="math inline">\(|x|\)</span>, 其中 || 为绝对值符 号。如果 <span class="math inline">\(|x| \in[1, N]\)</span> ，那么我们给数组中的第 <span class="math inline">\(|x|-1\)</span> 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加;</p></li><li><p>在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 <span class="math inline">\(N+1\)</span> ，否则答案是第一个正数的位置 加 1 。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) x = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">      <span class="keyword">if</span> (x &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = x - <span class="number">1</span>;</span><br><span class="line">        nums[idx] = -<span class="built_in">abs</span>(nums[idx]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="哈希" scheme="https://zgzheng.top/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记</title>
    <link href="https://zgzheng.top/2021/10/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://zgzheng.top/2021/10/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2021-10-18T10:09:56.000Z</published>
    <updated>2021-10-25T07:05:45.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法模板">算法模板</h1><h2 id="算法基础">算法基础</h2><h3 id="快速排序">快速排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;<span class="comment">//注意i,j起始位置是在l,r的越界位置</span></span><br><span class="line">    <span class="keyword">int</span> x=q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> ++i; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> --j; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span> (q[--j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quickSort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速选择">快速选择</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_select</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x=q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++i]&lt;x);</span><br><span class="line">        <span class="keyword">while</span>(q[--j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=j-l+<span class="number">1</span>; <span class="comment">// 已确定最小的n个数，在q[l~j]里面</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=k) <span class="keyword">return</span> <span class="built_in">quick_select</span>(q,l,j,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_select</span>(q,j+<span class="number">1</span>,r,k-n);<span class="comment">//还差k-n个数需要确定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j])temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)temp[k++]=q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;++i,++j)q[i]=temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数二分">整数二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数二分">浮点数二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度加法">高精度加法</h3><ul><li>vector存储数时，低位在头，高位在尾，这样有进位时push_back()效率高 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 高精度减法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 高精度*低精度 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 高精度/低精度 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 一维前缀和 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i从1开始</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure> ### 二维前缀和 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure> ### 一维差分 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给区间[l, r]中的每个数加上c：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    B[l] += c; </span><br><span class="line">    B[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 二维差分 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 位运算 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure> ### 双指针 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">寻找单调性</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure> ### 离散化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 区间合并 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="keyword">using</span> PII=pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSegs</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;PII&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">-2e9</span>,r=<span class="number">-2e9</span>;<span class="comment">//l,r初始值要小于区间可能范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg:segs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;seg.first)&#123;<span class="comment">//当前区间和[l,r]维护区间不相交</span></span><br><span class="line">            <span class="keyword">if</span>(l!=<span class="number">-2e9</span>)ans.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">            l=seg.first;<span class="comment">//更新l</span></span><br><span class="line">        &#125;</span><br><span class="line">        r=<span class="built_in">max</span>(r,seg.second);<span class="comment">//更新r,相交不相交都会更新r</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l!=<span class="number">-2e9</span>)ans.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    segs = ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据结构">数据结构</h2><h3 id="单链表">单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head,e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head=<span class="number">-1</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertHead</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAfter</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在第k个插入的数后插入数x</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;<span class="comment">//向链表头插入数x</span></span><br><span class="line">        e[idx]=x,ne[idx]=head,head=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAfter</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//删除第k个插入的数的后面的数</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;<span class="comment">//删除单链表头节点</span></span><br><span class="line">        head=ne[head];</span><br><span class="line">    &#125;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表">双链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e[N],l[N],r[N],idx;<span class="comment">//0,1存储点分别表示头尾哨兵head,tail,数据从2开始存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>,l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAfter</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在节点k(即存储下标k)后插入数x</span></span><br><span class="line">    e[idx]=x,l[idx]=k,r[idx]=r[k];</span><br><span class="line">    r[k]=idx,l[r[idx]]=idx;</span><br><span class="line">    ++idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeK</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈">栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stk[N],tt=<span class="number">0</span>;<span class="comment">//tt表示栈顶，0表示栈空，从1开始存储</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    stk[++tt]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    --tt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stk[tt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tt==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列">队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N],hh=<span class="number">0</span>,tt=<span class="number">-1</span>;<span class="comment">//从0开始存储数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q[++tt]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++hh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hh&gt;tt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列">循环队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N],hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    q[tt++]=x;</span><br><span class="line">    <span class="keyword">if</span>(tt==N)tt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hh++;</span><br><span class="line">    <span class="keyword">if</span>(hh==N)hh=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hh==tt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大/小的数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tt=<span class="number">0</span>;<span class="comment">//从1开始存储，0表示栈空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(tt&amp;&amp;<span class="built_in">check</span>(stk[tt],data[i])--tt;</span><br><span class="line">    stk[++tt]=i;<span class="comment">//一般存储的是下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列">单调队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;<span class="built_in">check_out</span>(q[hh]))++hh;<span class="comment">//检查当前队列队头hh要不要更新</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;<span class="built_in">check</span>(q[tt],data[i]))--tt;</span><br><span class="line">    q[++tt]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kmp">KMP</h3><ul><li>s是长文本串，长度为n，范围[1,2,3...n]</li><li>p是模式串，长度为m，范围[1,2,3...m]</li><li>s,p都是从下标1开始存储的！</li><li>ne[1]=0</li><li>next[j] 表示所有 p[1~j] 的相等的前缀和后最中长度的最大值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求模式串p的next数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="number">1</span>])j=ne[j];<span class="comment">//当前[1，j]是匹配的，长度为j</span></span><br><span class="line">    <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])++j;<span class="comment">//找到了匹配前缀，匹配长度+1；如果没找到，则ne[i]=0</span></span><br><span class="line">    ne[i]=j;<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])++j;</span><br><span class="line">    <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">        j=ne[j];<span class="comment">//进行下一轮匹配</span></span><br><span class="line">        <span class="comment">//匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trie-字典树">Trie 字典树</h3><ul><li>0号点既是根节点，又是空节点</li><li>son[ i ][ x ]存储字典树中当前节点 i 的值为x的子节点的位置</li><li>cnt[ i ]存储以当前节点 i 结尾的单词数量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;<span class="comment">//从根节点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>)son[p][u]= ++idx;<span class="comment">//son[p][u]指向空节点，即不存在，直接创建</span></span><br><span class="line">        p=son[p][u];<span class="comment">//跳转</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集">并查集</h3><ul><li><p>朴素并查集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[u]!=u)p[u]=<span class="built_in">findroot</span>(p[u]);</span><br><span class="line">    <span class="keyword">return</span> p[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)p[i]=i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pa=<span class="built_in">findroot</span>(a),pb=<span class="built_in">findroot</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(pa!=pb)p[pa]=pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>维护size的并查集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N],size[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[u]!=u)p[u]=<span class="built_in">findroot</span>(p[u]);</span><br><span class="line">    <span class="keyword">return</span> p[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">    size[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pa=<span class="built_in">findroot</span>(a),pb=<span class="built_in">findroot</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(pa!=pb)&#123;</span><br><span class="line">        size[pb]+=size[pa];</span><br><span class="line">        p[pa]=pb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>维护到祖宗节点距离的并查集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N],d[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[u]!=u)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">findroot</span>(p[u]);</span><br><span class="line">        d[u]+=d[p[u]];</span><br><span class="line">        p[u]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">    d[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pa=<span class="built_in">findroot</span>(a),pb=<span class="built_in">findroot</span>(b);</span><br><span class="line">    p[pa]=pb;</span><br><span class="line">    d[pa]=newdistance;<span class="comment">//根据具体问题初始化pa的偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="堆">堆</h3><ul><li>h[N]存储堆中的值，范围：[1,2,3,...,n]，从1开始存储，h[1]：堆顶</li><li>节点u ：<ul><li>左孩子：2u</li><li>右孩子：2u+1</li><li>父节点：u/2</li></ul></li><li>ph[k]：存储第k个插入的点在堆heap中的位置</li><li>hp[k]：存储堆heap中下标为k的位置处的节点是第几个插入的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N],ph[N],hp[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSwap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span>&amp;&amp;h[u]&lt;h[u/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">heapSwap</span>(u,u/<span class="number">2</span>);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*u&lt;=idx&amp;&amp;h[t]&gt;h[<span class="number">2</span>*u])t=<span class="number">2</span>*u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*u+<span class="number">1</span>&lt;=idx&amp;&amp;h[t]&gt;h[<span class="number">2</span>*u+<span class="number">1</span>])t=<span class="number">2</span>*u+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=u)&#123;</span><br><span class="line">        <span class="built_in">heapSwap</span>(t,u);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i;i--) <span class="built_in">down</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一般哈希">一般哈希</h3><ul><li><p>拉链法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    ne[idx]=h[k];</span><br><span class="line">    h[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[k];~i;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开放寻址法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> null=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=(x%N+N)%N;</span><br><span class="line">    <span class="keyword">while</span>(h[t]!=null&amp;&amp;h[t]!=x)&#123;</span><br><span class="line">        ++t;</span><br><span class="line">        <span class="keyword">if</span>(t==N)t=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串前缀哈希">字符串前缀哈希</h3><ul><li><p>核心思想：将字符串看成P进制数，P的经验值是<code>131</code>或<code>13331</code>，取这两个值的冲突概率低</p></li><li><p>小技巧：取模的数用<code>2^64</code>，这样直接用<code>unsigned long long</code>存储，溢出的结果就是取模的结果</p></li><li><p>h[0]=0，h[k]表示串长为k的前缀子串的哈希值，前缀和思想</p></li><li><p>p[k]表示p^k mod 2^64</p></li><li><figure><img src="C:\Users\XPS15\AppData\Roaming\Typora\typora-user-images\image-20210831200423013.png" alt="image-20210831200423013" /><figcaption aria-hidden="true">image-20210831200423013</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ULL=<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P=<span class="number">131</span>;</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*P;</span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]*P+str[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ULL <span class="title">hashsubstr</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h3 id="c-常用stl">C++ 常用STL</h3><ul><li><p>vector, 变长数组，倍增的思想 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size()  返回元素个数</span><br><span class="line">empty()  返回是否为空</span><br><span class="line">clear()  清空</span><br><span class="line">front()/back()</span><br><span class="line">push_back()/pop_back()</span><br><span class="line">begin()/end()</span><br><span class="line">[]</span><br><span class="line">支持比较运算，按字典序</span><br></pre></td></tr></table></figure></p></li><li><p>pair&lt;int, int&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first, 第一个元素</span><br><span class="line">second, 第二个元素</span><br><span class="line">支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br></pre></td></tr></table></figure></li><li><p>string，字符串 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size()/length()  返回字符串长度</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">substr(起始下标，(子串长度))  返回子串</span><br><span class="line">c_str()  返回字符串所在字符数组的起始地址</span><br></pre></td></tr></table></figure></p></li><li><p>queue, 队列</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">push()  向队尾插入一个元素</span><br><span class="line">front()  返回队头元素</span><br><span class="line">back()  返回队尾元素</span><br><span class="line">pop()  弹出队头元素</span><br></pre></td></tr></table></figure></p></li><li><p>priority_queue, 优先队列，默认是大根堆</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>()  插入一个元素</span><br><span class="line"><span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line"><span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">定义成小根堆的方式：priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure></p></li><li><p>stack, 栈 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">push()  向栈顶插入一个元素</span><br><span class="line">top()  返回栈顶元素</span><br><span class="line">pop()  弹出栈顶元素</span><br></pre></td></tr></table></figure></p></li><li><p>deque, 双端队列 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size()</span><br><span class="line">empty()</span><br><span class="line">clear()</span><br><span class="line">front()/back()</span><br><span class="line">push_back()/pop_back()</span><br><span class="line">push_front()/pop_front()</span><br><span class="line">begin()/end()</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p></li><li><p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</p><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br></pre></td></tr></table></figure></code></pre><ul><li>set/multiset <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">insert()  插入一个数</span><br><span class="line">find()  查找一个数</span><br><span class="line">count()  返回某一个数的个数</span><br><span class="line">erase()</span><br><span class="line">    (1) 输入是一个数x，删除所有x   O(k + logn)</span><br><span class="line">    (2) 输入一个迭代器，删除这个迭代器</span><br><span class="line">lower_bound()/upper_bound()</span><br><span class="line">    lower_bound(x)  返回大于等于x的最小的数的迭代器</span><br><span class="line">    upper_bound(x)  返回大于x的最小的数的迭代器</span><br></pre></td></tr></table></figure></li><li>map/multimap <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert()  插入的数是一个pair</span><br><span class="line">erase()  输入的参数是pair或者迭代器</span><br><span class="line">find()</span><br><span class="line">[]  注意multimap不支持此操作。 时间复杂度是 O(logn)</span><br><span class="line">lower_bound()/upper_bound()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">和上面类似，增删改查的时间复杂度是 O(1)</span><br><span class="line">不支持 lower_bound()/upper_bound()， 迭代器的++，--</span><br></pre></td></tr></table></figure></p></li><li><p>bitset, 圧位 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">count()  返回有多少个1</span><br><span class="line"></span><br><span class="line">any()  判断是否至少有一个1</span><br><span class="line">none()  判断是否全为0</span><br><span class="line"></span><br><span class="line">set()  把所有位置成1</span><br><span class="line">set(k, v)  将第k位变成v</span><br><span class="line">reset()  把所有位变成0</span><br><span class="line">flip()  等价于~</span><br><span class="line">flip(k) 把第k位取反</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="搜索与图论">搜索与图论</h2><h3 id="数与图的存储">数与图的存储</h3><ul><li><p>树是一种特殊的图，与图的存储方式相同。</p></li><li><p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。因此我们可以只考虑有向图的存储。</p><ul><li><p>邻接矩阵：g[a][b]</p></li><li><p>邻接表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="comment">//N是点数，M是边数,无向图M=N*2</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="数与图的遍历">数与图的遍历</h3><ul><li>时间复杂度O(V+E)</li></ul><h4 id="dfs深度优先遍历递归">DFS,深度优先遍历,递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>; <span class="comment">// visited[u] 表示点u已经被遍历过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (visited[j]==<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bfs广度优先遍历队列辅助">BFS,广度优先遍历，队列辅助</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    visited[u]=<span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(visited[j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                dis[j]=dis[t]+<span class="number">1</span>;<span class="comment">//记录距离</span></span><br><span class="line">                prev[j]=t;<span class="comment">//记录前一个点</span></span><br><span class="line">                visited[j]=<span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>BFS状态转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; d;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">string start,endstr=<span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(string start)</span></span>&#123;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    visited[start]=<span class="literal">true</span>;</span><br><span class="line">    d[start]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u==endstr) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果已经是目标状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k=u.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> ux=k/<span class="number">3</span>,uy=k%<span class="number">3</span>;<span class="comment">//二维坐标转一维坐标</span></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> vx=ux+dx[i],vy=uy+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(vx&gt;=<span class="number">0</span>&amp;&amp;vx&lt;<span class="number">3</span>&amp;&amp;vy&gt;=<span class="number">0</span>&amp;&amp;vy&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                string v=u;</span><br><span class="line">                <span class="built_in">swap</span>(v[k],v[vx*<span class="number">3</span>+vy]);</span><br><span class="line">                <span class="keyword">if</span>(visited[v]==<span class="literal">false</span>)&#123;<span class="comment">//如果当前状态未曾到达过</span></span><br><span class="line">                    d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">                    visited[v]=<span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="拓扑排序">拓扑排序</h3><h4 id="bfs队列入度拓扑排序">BFS队列入度拓扑排序</h4><ul><li>时间复杂度O(V+E)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topoSort_bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(--indeg[v]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>()==n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;不能拓扑排序&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dfs拓扑排序">DFS拓扑排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">statu</span>&#123;</span>unvisited=<span class="number">0</span>,visiting=<span class="number">1</span>,visited=<span class="number">2</span>&#125;;</span><br><span class="line">statu st[N];</span><br><span class="line"><span class="keyword">int</span> stk[N],tt;</span><br><span class="line"><span class="comment">//单趟dfs拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topodfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u]=<span class="number">1</span>;<span class="comment">//正在遍历中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]==<span class="number">0</span>)&#123;<span class="comment">//没有遍历过</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">topodfs</span>(j)==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(st[j]==<span class="number">1</span>)&#123;<span class="comment">//正在遍历中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[u]=<span class="number">2</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">    stk[++tt]=u;<span class="comment">//入栈存储</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断整个图能否拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">topodfs</span>(i)==<span class="literal">false</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;不能拓扑排序&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单源最短路">单源最短路</h3><h4 id="朴素dijkstra算法">朴素Dijkstra算法</h4><ul><li><p>O(V<sup>2</sup>) O(n<sup>2</sup>)</p></li><li><p>稠密图 <span class="math inline">\(E\approx V^2\)</span> 用邻接矩阵存图</p><p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251500084.png" /></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">集合S=&#123;当前已经确定最短距离的点&#125;</span><br><span class="line">更确切的含义：某个点是否已经更新过q</span><br><span class="line">dist[1]=0,dist[其他点]=+∞</span><br><span class="line">for i:1~n (循环n次)</span><br><span class="line"><span class="code">t&lt;-不在S中(没有确定最短距离)的离1号最近的点</span></span><br><span class="line"><span class="code">    s&lt;-t，t就是已经确定最短距离的点了</span></span><br><span class="line"><span class="code">    用t更新其他点的距离</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    g[a][b]=<span class="built_in">min</span>(g[a][b],w);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dist[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[j]==<span class="literal">false</span>&amp;&amp;(t==<span class="number">0</span>||dist[j]&lt;dist[t]))&#123;<span class="comment">//注意&amp;&amp;后要有括号</span></span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t==n)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆优化版的dijkstra算法">堆优化版的Dijkstra算法</h4><ul><li><p>O(ElogV) O(mlogn)</p></li><li><p>稀疏图 <span class="math inline">\(E\approx V\)</span> 用邻接表存图</p></li><li><p>堆实现方式：</p><ul><li><p>手写堆</p></li><li><p>STL优先队列（可能有冗余）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一号点的距离初始化为零，其他点初始化成无穷大。</span><br><span class="line">将一号点放入堆中。</span><br><span class="line">不断循环，直到堆空。每一次循环中执行的操作为：</span><br><span class="line">    弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点）。</span><br><span class="line">    用该点更新临界点的距离，若更新成功就加入到堆中。</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heapDijkstra</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    dist[u]=<span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,u&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> v=t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[v]==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v==n)<span class="keyword">break</span>;</span><br><span class="line">            st[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h[v];~i;i=ne[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j=e[i],weight=w[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;dist[v]+weight)&#123;</span><br><span class="line">                    dist[j]=dist[v]+weight;</span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="bellman-ford">Bellman-Ford</h4><ul><li><p>O(VE) O(mn)</p></li><li><p>如果存在负权环路，最短路可能不存在</p></li><li><p>若最短路不存在时，只能用来判断是否存在负环</p></li><li><p>如果第n次操作仍可以更新，则存在负环</p></li><li><p>需要注意的是，以S点为源点跑 Bellman-Ford 算法时，如果没有给出存在负环的结果，只能说明从S点出发不能抵达一个负环，而不能说明图上不存在负环。因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。</p></li><li><p>``` dist[1]=0,dist[其他点]=+∞ for n 次 (迭代k次涵义：从1号点经过不超过k条边的最短距离) for 所有边 a-&gt;b w dist[b]=min(dist[b],dist[a]+w) 松弛操作 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int a,b,w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line">void add(i,a,b,c)&#123;</span><br><span class="line">    edge[i]=&#123;a,b,c&#125;;</span><br><span class="line">&#125;</span><br><span class="line">bool bellmanford(int u,int k)&#123;//求出从u号点到n号点的最多经过k条边的最短距离</span><br><span class="line">    memset(dist,0x3f,sizeof dist);</span><br><span class="line">    dist[u]=0;</span><br><span class="line">    for(int i=0;i&lt;k;++i)&#123;</span><br><span class="line">        memcpy(backup,dist,sizeof dist);//备份！！！</span><br><span class="line">        for(int j=0;j&lt;m;++j)&#123;</span><br><span class="line">            auto e=edge[j];</span><br><span class="line">            dist[e.b]=min(dist[e.b],backup[e.a]+e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dist[n]&gt;0x3f3f3f3f/2)return false;//用0x3f3f3f3f/2仍是∞</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h4 id="spfa-bellman-ford队列优化版本">SPFA （Bellman-Ford队列优化版本）</h4><ul><li><p>一般O(E) O(m) 这时候可以代替堆优化Dijkstra</p></li><li><p>最坏O(VE) O(mn)</p></li><li><p>图中不可以含有负权环路</p></li><li><p>Shortest Path Faster Algorithm</p><figure><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251500935.png" alt="image-20211025150050568" /><figcaption aria-hidden="true">image-20211025150050568</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优化思路，当dist[a]变小时才需要更新dist[b]</span><br><span class="line">借助队列来实现,队列存储更新过变小的点。(队列元素不要重复存储，入队出队时更新维护状态变量)</span><br><span class="line"></span><br><span class="line">dist[x]表示1-&gt;x的最短距离</span><br><span class="line">cnt[x]表示最短路径上的边数</span><br><span class="line">cnt[x]&gt;=n,表示至少经过了n条边，则至少经过了n+1个点，故肯定有负权环路</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//目的只是记录一下当前发生过更新的点，且不重复</span></span><br><span class="line">    dist[u]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    st[u]=<span class="literal">true</span>;<span class="comment">//节点u在队列里面了</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> v=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        st[v]=<span class="literal">false</span>;<span class="comment">//出队，更新状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[v];~i;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i],weight=w[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[v]+weight)&#123;</span><br><span class="line">                dist[j]=dist[v]+weight;</span><br><span class="line">                <span class="keyword">if</span>(st[j]==<span class="literal">false</span>)&#123;<span class="comment">//只有当前节点j不在队列里面才会入队</span></span><br><span class="line">                    q.<span class="built_in">push</span>(j);<span class="comment">//入队</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;<span class="comment">//更新状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251501795.png" alt="image-20210906123819459" /><figcaption aria-hidden="true">image-20210906123819459</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfaNegaCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> v=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[v]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[v];~i;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i],weight=w[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[v]+weight)&#123;</span><br><span class="line">                dist[j]=dist[v]+weight;</span><br><span class="line">                cnt[j]=cnt[v]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(st[j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多源最短路">多源最短路</h3><h4 id="floyd算法">Floyd算法</h4><ul><li><p>O(V<sup>3</sup>) O(n<sup>3</sup>)</p></li><li><p>邻接矩阵存图，dist[N][N]，既可以存图，也可以当点i，j距离</p></li><li><p>可以处理负权图，但不能有负权环路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d[k,i,j]表示i-&gt;1~k-&gt;j,从点i只经过1~k这些中间点到达j的最短距离</span><br><span class="line">d[k,i,j]=d[k-1,i,k]+d[k-1,k,j]</span><br><span class="line">d[i,j]=d[i,k]+d[k,j]</span><br><span class="line">for(k=1;k&lt;=n;++k)&#123;</span><br><span class="line">for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">for(int j=1;j&lt;=n;++j)&#123;</span><br><span class="line">d[i,j]=min(d[i,j],d[i,k]+d[k,j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">d[i,j]表示i-&gt;j的最短路长度</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        dist[i][i]=<span class="number">0</span>;<span class="comment">//删除自环，题目保证没有负权回路，数据中dist[a][b]&gt;=0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    dist[a][b]=<span class="built_in">min</span>(dist[a][b],c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;++k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                dist[i][j]=<span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251501442.png" alt="image-20210903215246003" /><figcaption aria-hidden="true">image-20210903215246003</figcaption></figure><h3 id="最小生成树">最小生成树</h3><p><a href="https://www.bilibili.com/video/BV1Eb41177d1/">B站优质讲解</a></p><h4 id="普利姆算法prim">普利姆算法Prim</h4><ul><li><p>如果图的每一条边的权值都互不相同，那么最小生成树将只有一个，否则可能会有多个最小生成树</p></li><li><p>Prim算法是基于切分定理</p><figure><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251501315.png" alt="image-20210906193721810" /><figcaption aria-hidden="true">image-20210906193721810</figcaption></figure></li></ul><h5 id="朴素版prim">朴素版Prim</h5><ul><li><p>稠密图适用</p></li><li><p>O(n<sup>2</sup>)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dist[i]&lt;-∞</span><br><span class="line">集合S=&#123;当前已经在连通块中的所有点&#125;</span><br><span class="line">for(i=0;i<span class="xml">&lt;n;++i)</span></span><br><span class="line"><span class="xml">v&lt;-找到集合外距离最近的点</span></span><br><span class="line"><span class="xml">用v更新其它点到_集合_的距离(Dijkstra算法为到源点距离)</span></span><br><span class="line"><span class="xml">st[v]=true，将点v加入到集合</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[j]==<span class="literal">false</span>&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))&#123;</span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有点不连通的时候，不存在最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//dist[t]是最小的横切边，必然属于最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(i)res+=dist[t];</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            dist[j]=<span class="built_in">min</span>(dist[j],g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="堆优化版prim">堆优化版Prim</h5><ul><li><p>不常用</p></li><li><p>O(mlogn)</p></li></ul><h4 id="克鲁斯卡尔算法kruskal">克鲁斯卡尔算法Kruskal</h4><ul><li><p>稀疏图适用</p></li><li><p>O(mlogm)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将所有边按权重从小到大排序 </span><br><span class="line">枚举每条边a-&gt;b,权重w</span><br><span class="line">if a,b不连通</span><br><span class="line">将这条边加入集合</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;e)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edge,edge+idx);<span class="comment">//边排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i]=i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;idx;++i)&#123;<span class="comment">//枚举边</span></span><br><span class="line">        <span class="keyword">int</span> a=edge[i].a,b=edge[i].b,w=edge[i].w;</span><br><span class="line">        <span class="keyword">int</span> pa=<span class="built_in">findroot</span>(a),pb=<span class="built_in">findroot</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa!=pb)&#123;<span class="comment">//不连通</span></span><br><span class="line">            p[pa]=pb;<span class="comment">//合并成连通块</span></span><br><span class="line">            res+=w;</span><br><span class="line">            ++cnt;<span class="comment">//记录连通块中边的数量</span></span><br><span class="line">            <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">//可以提前结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二分图">二分图</h3><ul><li>二分图当且仅当图中不含有奇数环</li></ul><h4 id="染色法">染色法</h4><ul><li>O(n+m)</li></ul><h5 id="dfs版染色法">DFS版染色法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(color[j]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i,<span class="number">1</span>)==<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bfs版染色法">BFS版染色法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    color[u]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(color[j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                color[j]=<span class="number">3</span>-color[t];</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[j]==color[t])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">bfs</span>(i)==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匈牙利算法">匈牙利算法</h4><ul><li>最坏O(mn)，实际运行时间远小于O(mn)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findmatch</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];~i;i=ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j]==<span class="literal">false</span>)&#123;</span><br><span class="line">            st[j]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[j]==<span class="number">0</span>||<span class="built_in">findmatch</span>(match[j]))&#123;</span><br><span class="line">                match[j]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxmatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">findmatch</span>(i))&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学知识">数学知识</h2><h3 id="位运算">位运算</h3><h4 id="按位异或">按位异或</h4><ol type="1"><li><strong>归零率</strong> <span class="math inline">\(a\oplus a=0\)</span></li><li><strong>恒等率</strong> <span class="math inline">\(a\oplus0=a\)</span></li><li><span class="math inline">\(a\oplus1=\sim a\)</span></li></ol><h3 id="质数素数prime">质数（素数）Prime</h3><ul><li>定义：质数又称<a href="https://baike.baidu.com/item/素数/115069">素数</a>。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为<a href="https://baike.baidu.com/item/合数/49186">合数</a>（规定1既不是质数也不是合数）</li></ul><h5 id="质数的判定试除法">质数的判定——试除法</h5><ul><li><p>“d|n"表示d能整除n</p></li><li><p>一个合数的<strong>约数</strong>总是成对出现的，若d|n，则(n/d)|n，因此我们判读一个数是否为质数的时候，只需要判断较小的那个数能否整除n就行了，即只需要枚举到d&lt;=(n/d)，即d*d&lt;=n，d&lt;=sqrt(n)就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqrtX=<span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqrtX;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="分解质因数试除法">分解质因数——试除法</h5><blockquote><p><strong>算数基本定理</strong>：任何一个大于1的自然数N，如果N不为质数，那么N可以<strong>唯一</strong>分解成有限个质数的乘积。</p><p><span class="math inline">\(N=P_1^{a_1}P_2^{a_2}P_3^{a_3}...P_n^{a_n}\)</span>，这里<span class="math inline">\(P_1&lt;P_2&lt;P_3&lt;...&lt;P_n\)</span>均为质数，其中指数<span class="math inline">\(a_i\)</span>是正整数。</p><p>这样的分解称为<em>N</em>的标准分解式。</p><ul><li><p>一个大于1的正整数<span class="math inline">\(N\)</span>，如果它的标准分解式为：<span class="math inline">\(N=P_1^{a_1}P_2^{a_2}...P_n^{a_n}\)</span>，</p></li><li><p>正因数个数为：</p><p><span class="math inline">\(\sigma_0(N)=(1+a_1)(1+a_2)(1+a_3)...(1+a_n)\)</span></p></li><li><p>正因数之和为：<span class="math inline">\(\sigma_1(N)=(1+p_1+p_1^2+...+p_1^{a_1})(1+p_2+p_2^2+...+p_2^{a_2})...(1+p_n+p_n^2+...+p_n^{a_n})\)</span></p><p>当<span class="math inline">\(\sigma_1=2N\)</span>时就称<em>N</em>为完全数。</p></li><li><p>整数a,b的最大公因子<span class="math inline">\((a,b)\)</span>和最小公倍数<span class="math inline">\([a,b]\)</span>，则<span class="math inline">\(ab=(a,b)\times[a,b]\)</span></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ++prime[i];</span><br><span class="line">            n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ++prime[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个合数分解而成的质因数最多只包含一个大于<span class="math inline">\(sqrt(n)\)</span>的质因数</li><li>当枚举到一个数 <span class="math inline">\(i\)</span> 的时候，<span class="math inline">\(n\)</span> 的因子里面已经不包含$ [2,i-1] <span class="math inline">\(里面的数（已经被除干净了）。 如果\)</span>n%i==0$，则 <span class="math inline">\(i\)</span> 的因子里面也已经不包含 <span class="math inline">\([2,i-1]\)</span> 里面的数，因此每次枚举的数都是<strong>质数</strong></li><li><strong>两个没有共同质因子的正整数称为互质</strong>。因为 <span class="math inline">\(1\)</span> 没有质因子，故 <span class="math inline">\(1\)</span> 与任何正整数（包括 <span class="math inline">\(1\)</span> 本身）都是互质。</li><li>只有一个质因子的正整数也即质数。</li></ul><h5 id="筛质数朴素筛法">筛质数（朴素筛法）</h5><ul><li><p>步骤：把 <span class="math inline">\([2,n-1]\)</span> 中所有的数的倍数都标记上，最后没有被标记的数就是质数。</p></li><li><p>原理：假定有一个数 <span class="math inline">\(p\)</span> 未被 <span class="math inline">\([2,p-1]\)</span> 中的数标记过，那么说明，不存在 <span class="math inline">\([2,p-1]\)</span> 中的任何一个数的倍数时 <span class="math inline">\(p\)</span> ，也就是说 <span class="math inline">\([2,p-1]\)</span> 中不存在 <span class="math inline">\(p\)</span> 的约数，因此，根据质数的定义可知：<span class="math inline">\(p\)</span> 是质数。</p></li><li><p><span class="math inline">\(O(nlogn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> notprime[N];</span><br><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(notprime[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[cnt++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)&#123;</span><br><span class="line">            notprime[j]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="埃式筛法稍加优化版的朴素筛法">埃式筛法（稍加优化版的朴素筛法）</h5><ul><li>质数定理：<span class="math inline">\(1\sim n\)</span> 中有<span class="math inline">\(n\over \ln n\)</span> 个质数。</li><li>步骤：在朴素筛法的过程中只用<strong>质数项</strong>去筛</li><li><span class="math inline">\(O(nlog(logn))\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> composite[N];</span><br><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(composite[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[cnt++]=i;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=n/i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;=n;j+=i)&#123;</span><br><span class="line">                    composite[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//因为从2到i-1的倍数我们之前筛过了</span></span><br><span class="line">                <span class="comment">//这里直接从i倍开始，提高了运行速度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线性筛法">线性筛法</h5><ul><li><p>若<span class="math inline">\(n\approx10^6\)</span>，线性筛和埃式筛的时间效率差不多，若<span class="math inline">\(n\approx10^7\)</span>，线性筛比埃式筛要快一倍</p></li><li><p>核心： <span class="math inline">\(1\sim n\)</span> 内的每一个合数 <span class="math inline">\(p\)</span> 只被其<strong>最小质因子</strong>筛掉</p></li><li><p>原理： <span class="math inline">\(1\sim n\)</span> 之内的任何一个合数一定会被筛掉，而且筛的时候只用<strong>最小质因子</strong>来筛，然后每一个数都只有一个最小质因子，因此每个数都只会被筛一次，因此线性筛法是线性的</p></li><li><p>当<code>i%primes[j]!=0</code>时,说明此时遍历到的<code>primes[j]</code>不是<code>i</code>的质因子，那么<code>primes[j]</code>一定小于<code>i</code>的最小质因子，所以<code>primes[j]*i</code>的最小质因子就是<code>primes[j]</code>;</p></li><li><p>当有<code>i%primes[j]==0</code>时,说明<code>i</code>的最小质因子是<code>primes[j]</code>,因此<code>primes[j]*i</code>的最小质因子也就应该是 <code>prime[j]</code>。</p><p>之后接着用<code>st[primes[j+1]*i]=true</code>去筛合数时，就不是用最小质因子去更新了,因为<code>i</code>有最小质因子<code>primes[j]</code>,此时的<code>primes[j+1]</code>不是<code>primes[j+1]*i</code>的最小质因子，此时就应该退出循环，避免之后重复进行筛选。</p></li><li><p><span class="math inline">\(O(n)\)</span></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> composite[N];</span><br><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(composite[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[cnt++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;prime[j]&lt;=n/i;++j)&#123;</span><br><span class="line">            composite[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数因数divisorfactor">约数（因数）Divisor（Factor）</h3><ul><li>定义：若整数 <span class="math inline">\(n\)</span> 除以整数 <span class="math inline">\(d\)</span> 的余数为0，即 <span class="math inline">\(d\)</span> 能整除 <span class="math inline">\(n\)</span> ，则称 <span class="math inline">\(d\)</span> 是 <span class="math inline">\(n\)</span> 的约数，<span class="math inline">\(n\)</span> 是 <span class="math inline">\(d\)</span> 的倍数，记为 <span class="math inline">\(d|n\)</span> 。</li></ul><blockquote><p>在算数基本定理中，若正整数 <span class="math inline">\(N\)</span> 被唯一分解为 <span class="math inline">\(N=p_{1}^{c_{1}} p_{2}^{c_{2}} \cdots p_{m}^{c_{m}}\)</span> ，其中 <span class="math inline">\(c_i\)</span> 都是正整数， <span class="math inline">\(p_i\)</span> 都是质数，且满足 <span class="math inline">\(p_{1}&lt;p_{2}&lt;\cdots&lt;p_{m}\)</span> ，则 <span class="math inline">\(N\)</span> 的正约数集合可写作： <span class="math display">\[\left\{p_{1}^{b_{1}} p_{2}^{b_{2}} \cdots p_{m}^{b_{m}}\right\}, \text { 其中 } 0 \leq b_{i} \leq c_{i}\]</span> <span class="math inline">\(N\)</span> 的正约数个数为： <span class="math display">\[\left(c_{1}+1\right) *\left(c_{2}+1\right) * \cdots *\left(c_{m}+1\right)=\prod_{i=1}^{m}\left(c_{i}+1\right)\]</span> <span class="math inline">\(N\)</span> 的所有正约数的和为： <span class="math display">\[\left(1+p_{1}+p_{1}^{2}+\cdots+p_{1}^{c_{1}}\right) * \cdots *\left(1+p_{m}+p_{m}^{2}+\cdots+p_{m}^{c_{m}}\right)=\prod_{i=1}^{m}\left(\sum_{j=0}^{c_{i}}\left(p_{i}\right)^{j}\right)\]</span></p></blockquote><h5 id="求-n-的正约数集合试除法">求 <span class="math inline">\(N\)</span> 的正约数集合——试除法</h5><ul><li><p>若 <span class="math inline">\(d \geq \sqrt{N}\)</span> 是 <span class="math inline">\(N\)</span> 的约数，则 <span class="math inline">\(N / d \leq \sqrt{N}\)</span> 也是 <span class="math inline">\(N\)</span> 的约数。</p><p>换言之，约数总是成对出现的（除了对于完全平方数，<span class="math inline">\(\sqrt{N}\)</span> 会单独出现）。</p></li><li><p>因此，只需要扫描 <span class="math inline">\(d=1 \sim \sqrt{N}\)</span> ，尝试 <span class="math inline">\(d\)</span> 能否整除 <span class="math inline">\(N\)</span> ，若能整除，则 <span class="math inline">\(N/d\)</span> 也是 <span class="math inline">\(N\)</span> 的约数。</p></li><li><p>推论：一个整数 <span class="math inline">\(N\)</span> 的约数个数上界为 <span class="math inline">\(2\sqrt{N}\)</span> 。</p></li><li><p><span class="math inline">\(O(\sqrt{N})\)</span></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getFactor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; factor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            factor.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i!=n/i)factor.<span class="built_in">push_back</span>(n/i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(factor.<span class="built_in">begin</span>(),factor.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> factor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="求-n-的约数个数">求 <span class="math inline">\(N\)</span> 的约数个数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrimeFactor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ++prime[i];</span><br><span class="line">            n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ++prime[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> countFactor=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it:prime)&#123;</span><br><span class="line">    countFactor=countFactor*(it.second+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求-n-的约数之和">求 <span class="math inline">\(N\)</span> 的约数之和</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrimeFactor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ++prime[i];</span><br><span class="line">            n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ++prime[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it:prime)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p=it.first, index=it.second;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">        sum=(sum*p+<span class="number">1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    res=res*sum%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最大公约数">最大公约数</h5><ul><li><p>欧几里得算法 （辗转相除法）</p></li><li><p>$ gcd(a,b)=gcd(b,ab)$</p></li><li><p><span class="math inline">\(O(logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">int</span> r=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="欧拉函数">欧拉函数</h4><h5 id="定义和性质">定义和性质</h5><blockquote><p>互质：<span class="math inline">\(\forall a, b \in \mathbb{N} \text {, 若 } \operatorname{gcd}(a, b)=1, \text { 则称 } a, b \text { 互质 }\)</span></p></blockquote><blockquote><p>欧拉函数：<span class="math inline">\(1 \sim N \text { 中与 } N \text { 互质的数的个数被称为欧拉函数, 记为 } \varphi(N)\)</span></p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251502919.png" alt="image-20210911155540376" /><figcaption aria-hidden="true">image-20210911155540376</figcaption></figure><h5 id="求欧拉函数">求欧拉函数</h5><ul><li><span class="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            cnt=cnt/i*(i<span class="number">-1</span>); <span class="comment">//先除后乘防溢出</span></span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;<span class="comment">//注意要用while把质数i除干净</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) cnt=cnt/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="筛法求欧拉函数">筛法求欧拉函数</h5><ul><li><span class="math inline">\(O(n)\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[N],cnt;</span><br><span class="line"><span class="keyword">bool</span> iscomposite[N];</span><br><span class="line"><span class="keyword">int</span> e[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getEulers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    e[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//注意要写上！！！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(iscomposite[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">            prime[cnt++]=i;</span><br><span class="line">            e[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;prime[j]&lt;=n/i;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> p=prime[j];</span><br><span class="line">            iscomposite[p*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p==<span class="number">0</span>)&#123;<span class="comment">//p是i的最小质因子</span></span><br><span class="line">                e[p*i]=p*e[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//p与i互质</span></span><br><span class="line">                e[p*i]=e[p]*e[i];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="欧拉定理">欧拉定理</h5><p>若 <span class="math inline">\(\operatorname{gcd}(a, m)=1\)</span> ，则 <span class="math inline">\(a^{\varphi(m)} \equiv 1\ (\bmod m)\)</span></p><h5 id="扩展欧拉定理">扩展欧拉定理</h5><p><span class="math display">\[a^{b} \equiv \begin{cases}a^{b\;\bmod\; \varphi(m)}, &amp; \operatorname{gcd}(a, m)=1, \\ a^{b}, &amp; \operatorname{gcd}(a, m) \neq 1, b&lt;\varphi(m), \quad(\bmod m) \\ a^{b\;\bmod \;\varphi(m)+\varphi(m)}, &amp; \operatorname{gcd}(a, m) \neq 1, b \geq \varphi(m) .\end{cases}\]</span></p><h5 id="费马小定理">费马小定理</h5><ul><li><p><span class="math inline">\(p\)</span> 为质数</p></li><li><p>若 <span class="math inline">\(\operatorname{gcd}(a, p)=1\)</span>， 则 <span class="math inline">\(a^{p-1} \equiv 1\ (\bmod p)\)</span></p></li><li><p><span class="math inline">\(\forall a \in \mathbb{Z}\)</span>，有 <span class="math inline">\(a^{p} \equiv a \ (\bmod p)\)</span></p><p><span class="math display">\[a^{b} \equiv \begin{cases}a^{b\;\bmod\;\varphi(p)}, &amp; \operatorname{gcd}(a, p)=1, \\ a^{b}, &amp; \operatorname{gcd}(a, p) \neq 1, b&lt;\varphi(p) \quad(\bmod p) \\ a^{b\;\bmod \;\varphi(p)+\varphi(p)}, &amp; \operatorname{gcd}(a, p) \neq 1, b \geq \varphi(p) \end{cases}\quad\varphi(p)=p-1\]</span></p></li></ul><h4 id="快速幂">快速幂</h4><ul><li><span class="math inline">\(\Theta(\log n)\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span> ;</span><br><span class="line"><span class="function">LL <span class="title">binpow</span><span class="params">(LL a,LL n,LL p)</span></span>&#123;</span><br><span class="line">    a%=p;</span><br><span class="line">    LL res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)res=res*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="裴蜀定理">裴蜀定理</h4><ul><li>设 <span class="math inline">\(a,b\)</span> 是不全为零的整数，则存在整数 <span class="math inline">\(x,y\)</span>，使得 <span class="math inline">\(ax+by=\gcd (a,b)\)</span></li></ul><h4 id="扩展欧几里得算法-exgcd">扩展欧几里得算法 EXGCD</h4><h5 id="算法原理">算法原理</h5><blockquote><p>求解 <span class="math inline">\(ax+by=\gcd (a,b)\)</span></p><p>由欧几里得定理可知：<span class="math inline">\(\gcd (a,b)=\gcd(b,a\mod b)\)</span></p><p>设 <span class="math inline">\(ax_1+by_1=\gcd (a,b) =\gcd (b,a\mod b)=bx_2+(a\mod b)y_2\)</span></p><p>$a b=a-(abb) $</p><p><span class="math inline">\(ax_1+by_1=bx_2+(a-\lfloor \frac ab\rfloor \times b)y_2=ay_2+b(x_2-\lfloor \frac ab \rfloor y_2)\)</span></p><p>故 <span class="math inline">\(x_1=y_2\ ,\ y_1=x_2-\lfloor \frac ab \rfloor y_2\)</span></p></blockquote><h5 id="递归写法">递归写法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x1,<span class="keyword">int</span> &amp;y1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x1=<span class="number">1</span>,y1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x2,y2;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="built_in">exgcd</span>(b,a%b,x2,y2);</span><br><span class="line">    x1=y2,y1=x2-(a/b)*y2;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="矩阵解释">矩阵解释</h5><p><span class="math inline">\(\gcd(a,b)=\gcd(b,a\bmod b)\)</span> 使用矩阵表示为 <span class="math display">\[\begin{bmatrix}b\\a\bmod b\end{bmatrix}=\begin{bmatrix}0&amp;1\\1&amp;-\lfloor \frac ab \rfloor\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}\]</span> 定义变换： <span class="math display">\[\begin{bmatrix}a\\b\end{bmatrix}\mapsto\begin{bmatrix}0&amp;1\\1&amp;-\lfloor \frac ab \rfloor\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}=\begin{bmatrix}b\\a\bmod b\end{bmatrix}\]</span> 欧几里得算法即不停应用该变换 <span class="math display">\[\left(\begin{bmatrix}0&amp;1\\1&amp;-\lfloor \frac ab \rfloor\end{bmatrix}\cdots\begin{bmatrix}0&amp;1\\1&amp;-\lfloor \frac ab \rfloor\end{bmatrix}\right)\begin{bmatrix}a\\b\end{bmatrix}=\begin{bmatrix}\gcd(a,b)\\0\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x_1&amp;x_2\\x_3&amp;x_4\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}=\begin{bmatrix}\gcd(a,b)\\0\end{bmatrix}\]</span></p><p>则有 <span class="math inline">\(ax_1+bx_2=\gcd(a,b)\)</span></p><p>初始化： <span class="math display">\[\begin{bmatrix}x_1&amp;x_2\\x_3&amp;x_4\end{bmatrix}=\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}\]</span> 迭代： <span class="math display">\[\begin{bmatrix}a\\b\end{bmatrix}\mapsto\begin{bmatrix}0&amp;1\\1&amp;-\lfloor \frac ab \rfloor\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}=\begin{bmatrix}b\\a\bmod b\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}x_1&amp;x_2\\x_3&amp;x_4\end{bmatrix}\mapsto\begin{bmatrix}0&amp;1\\1&amp;-\lfloor \frac ab \rfloor\end{bmatrix}\begin{bmatrix}x_1&amp;x_2\\x_3&amp;x_4\end{bmatrix}=\begin{bmatrix}x_3&amp;x_4\\x_1-\lfloor \frac ab \rfloor x_3&amp;x_2-\lfloor \frac ab \rfloor x_4\end{bmatrix}\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">1</span>,x2=<span class="number">0</span>,x3=<span class="number">0</span>,x4=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=a/b,tx1=x1,tx2=x2;</span><br><span class="line">        x1=x3,x2=x4,x3=tx1-c*x3,x4=tx2-c*x4;</span><br><span class="line">        <span class="keyword">int</span> r=a%b;</span><br><span class="line">        a=b,b=r;</span><br><span class="line">    &#125;</span><br><span class="line">    x=x1,y=x2;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">1</span>,x2=<span class="number">0</span>,x3=<span class="number">0</span>,x4=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=a/b;</span><br><span class="line">        <span class="built_in">tie</span>(x1,x2,x3,x4,a,b)=<span class="built_in">make_tuple</span>(x3,x4,x1-c*x3,x2-c*x4,b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">    x=x1,y=x2;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求解axbyc">求解<span class="math inline">\(ax+by=c\)</span></h5><ul><li><p><span class="math inline">\(ax+by=c\)</span> 有解当且仅当 <span class="math inline">\(\gcd(a,b)|c\)</span></p><p>先求得 <span class="math inline">\(ax_0+by_0=\gcd (a,b)=d\)</span> 的解 <span class="math inline">\(x_0,y_0\)</span></p><p>则有特解 <span class="math inline">\(x&#39;=x_0\frac cd\;,y&#39;=y_0\frac cd\)</span></p><p>故通解为 <span class="math inline">\(x=x_0\frac cd +k\frac bd,y=y_0\frac cd -k\frac ad\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line"><span class="keyword">if</span>(c%d==<span class="number">0</span>) cout&lt;&lt;x*<span class="number">1LL</span>*c/d&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ul><h5 id="求线性同余方程axequiv-cbmodb">求线性同余方程<span class="math inline">\(ax\equiv c\;(\bmod\;b)\)</span></h5><ul><li><p><span class="math inline">\(ax\equiv c\;(\bmod\;b) \Leftrightarrow\; ax=(-y)\times b+c\;\Leftrightarrow\; ax+by=c\)</span></p></li><li><p>有解当且仅当<span class="math inline">\(\gcd(a,b)|c\)</span> ，特别的，当 <span class="math inline">\(c=1\)</span> ，<span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 互质时，则所求的 <span class="math inline">\(x\)</span>为 <span class="math inline">\(a\)</span> 的逆元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line"><span class="keyword">if</span>(c%d==<span class="number">0</span>) cout&lt;&lt;x*<span class="number">1LL</span>*c/d&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ul><h4 id="逆元">逆元</h4><ul><li>如果一个线性同余方程 <span class="math inline">\(ax\equiv 1\;(\bmod m)\)</span> ，则 <span class="math inline">\(x\)</span> 称为 <span class="math inline">\(a\bmod m\)</span> 的逆元，记作 <span class="math inline">\(a^{-1}\)</span><br /></li><li><span class="math inline">\(a\)</span> 逆元存在的充要条件是 <span class="math inline">\(a,m\)</span> 互质，<span class="math inline">\(\gcd(a,m)=1\)</span></li><li>$aa<sup>{-1};(m);,;bb</sup>{-1};(m)aba<sup>{-1}b</sup>{-1} ;(m);,;(ab)<sup>{-1}=a</sup>{-1}b^{-1} $</li></ul><h5 id="扩展欧几里得法求逆元">扩展欧几里得法求逆元</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> d=<span class="built_in">exgcd</span>(a,m,x,y);</span><br><span class="line"><span class="keyword">if</span>(d==<span class="number">1</span>) cout&lt;&lt;((LL)x%p+p)%p&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="快速幂法求逆元模m必须为质数">快速幂法求逆元（模m必须为质数）</h5><p>若 <span class="math inline">\(m\)</span> 为质数，则根据费马小定理有 <span class="math inline">\(a^{m}\equiv a\;(\bmod m)\)</span></p><p>因为 <span class="math inline">\(ax\equiv 1\;(\bmod m)\)</span> ，故 <span class="math inline">\(a^2x\equiv a\equiv a^m\;(\bmod m)\)</span></p><p><span class="math inline">\(a,m\)</span> 互质，则有 <span class="math inline">\(x=a^{-1}\equiv a^{m-2}\;(\bmod m)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">binpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    a%=p;</span><br><span class="line">    LL res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)res=res*a%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*<span class="number">1LL</span>*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里模m必须为质数</span></span><br><span class="line"><span class="keyword">if</span>(a%m) cout&lt;&lt;<span class="built_in">binpow</span>(a,m<span class="number">-2</span>,m)%&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h4 id="中国剩余定理crt">中国剩余定理CRT</h4><blockquote><p>求解如下形式的一元线性同余方程组：</p><p><span class="math inline">\(\left\{\begin{aligned} x &amp; \equiv a_{1}\left(\bmod n_{1}\right) \\ x &amp; \equiv a_{2}\left(\bmod n_{2}\right) \\ &amp; \vdots \\ x &amp; \equiv a_{k}\left(\bmod n_{k}\right) \end{aligned}\right.\)</span></p><p>其中 <span class="math inline">\(n_1,n_2,\cdots,n_k\)</span> 两两互质</p></blockquote><blockquote><p>算法流程:</p><ol type="1"><li>计算所有模数的积 <span class="math inline">\(n=n_1\times n_2\times n_3\times\cdots\times n_k\)</span></li><li>对于第 <span class="math inline">\(i\)</span> 个方程：<ul><li>计算 <span class="math inline">\(m_i=\frac n{n_i}\)</span></li><li>计算 <span class="math inline">\(m_i\)</span> 在模 <span class="math inline">\(n_i\)</span> 意义下的逆元 <span class="math inline">\(m_i^{-1}\)</span></li><li>计算 <span class="math inline">\(c_i=m_im_i^{-1}\)</span> (不要对 <span class="math inline">\(n_i\)</span> 取模)</li></ul></li><li>方程组的唯一解为：<span class="math inline">\(x=\sum_{i=1}^{k}a_ic_i\;(\bmod n)\)</span></li><li>通解为：<span class="math inline">\(x+km\;(k\in\Z)\)</span></li></ol></blockquote><h5 id="模数不互质的情况">模数不互质的情况</h5><ul><li><p>两个方程</p><p><span class="math inline">\(\begin{cases} x\equiv a_1\;(\bmod m_1)\\x\equiv a_2\;(\bmod m_2)\end{cases}\)</span></p><p>转为不定方程 <span class="math inline">\(x=m_1k_1+a_1=m_2k_2+a_2\)</span> ，其中 <span class="math inline">\(k_1,k_2\)</span> 是整数</p><p>则有 <span class="math inline">\(m_1k_1-m_2k_2=a_2-a_1\)</span></p><p>由裴蜀定理，若 <span class="math inline">\(\gcd(m_1,m_2)\nmid a_2-a_1\)</span> ，不定方程无解。</p><p>若 <span class="math inline">\(\gcd(m_1,m_2)\mid a_2-a_1\)</span> ，可由扩展欧几里得算法求出一组可行解 <span class="math inline">\((k_1,k_2)\)</span></p><p>则原方程解为 <span class="math inline">\(x\equiv b\;(\bmod M)\)</span> ，其中 <span class="math inline">\(b=m_1k_1+a_1\;,\;M=\text{lcm} (m_1,m_2)\)</span></p><ul><li><p>欧几里得算法求解 <span class="math inline">\(m_1k_{01}+m_2k_{02}=a_2-a_1\)</span></p></li><li><p><span class="math inline">\(d=\text{exgcd}(m_1,m_2,k_{01},k_{02})\)</span> 得特解 <span class="math inline">\(k_1&#39;=\frac {a_2-a_1}{d} k_{01},k_2&#39;=\frac {a_2-a_1}{d} k_{02}\)</span></p></li><li><p>则有通解</p><p><span class="math inline">\(k_1=k&#39;+k\frac {m_2}{d}=\frac {a_2-a_1}{d} k_{01}+k\frac{m_2}{d}\)</span></p><p><span class="math inline">\(k_2=-(k_2&#39;-k\frac{m_1}{d})=-\frac {a_2-a_1}{d} k_{02}+k\frac{m_1}{d}\)</span></p><p>其中 <span class="math inline">\(k\in \Z\)</span></p></li><li><p>为了防止计算过程中出现溢出，需要在通解 <span class="math inline">\(k_1\)</span> 中选出一个尽可能小的特解<span class="math inline">\(k_1^*\)</span> 替代 <span class="math inline">\(k_{01}\)</span> ，此处取为最小正整数特解。</p><blockquote><p>C++中求 <span class="math inline">\(x=x_0+kd\)</span> 的最小正整数解：</p><p><span class="math inline">\((x\%d+d)\%d\)</span></p></blockquote><p><span class="math inline">\(k_1^*=(k_1\% \frac {m_2}{d}+\frac{m_2}{d})+\frac{m_2}{d}\)</span></p><p><span class="math inline">\(k_1=k_1^*+k\frac {m_2}{d}\)</span></p></li><li><p>将求出的 <span class="math inline">\(k_1^{*}\)</span> 代入原不定方程得：</p><p><span class="math inline">\(x=m_1k_1+a_1=m_1k_1^*+m_1k\frac {m_2}{d}+a_1=k\frac{m_1m_2}{d}+(a_1+m_1k_1^*)\)</span></p><p>记 <span class="math inline">\(a=a_1+m_1k_1^*\;,\;m=\frac{m_1m_2}{d}=\text{lcm}(m_1,m_2)\)</span></p><p>则原来的两个方程可以表示为：</p><p><span class="math inline">\(x=km+a\)</span> 即 <span class="math inline">\(x\equiv a\;(\bmod m)\)</span></p></li></ul></li><li><p>多个方程</p><p>用上面的方法两两合并即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">usign LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> n; cin&gt;&gt;n;</span><br><span class="line">LL a1,m1; cin&gt;&gt;m1&gt;&gt;a1;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(--n)&#123;</span><br><span class="line">    LL a2,m2; cin&gt;&gt;m2&gt;&gt;a2;</span><br><span class="line">    LL k1,k2;</span><br><span class="line">    LL d=<span class="built_in">exgcd</span>(m1,m2,k1,k2);</span><br><span class="line">    <span class="keyword">if</span>((a2-a1)%d==<span class="number">0</span>)&#123;</span><br><span class="line">        k1*=(a2-a1)/d;</span><br><span class="line">        LL mod=m2/d;</span><br><span class="line">        k1=(k1%mod+mod)%mod;</span><br><span class="line">        a1+=m1*k1;</span><br><span class="line">        m1*=mod;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) cout&lt;&lt;a1%m1&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ul><h4 id="高斯消元">高斯消元</h4><ul><li>通过初等行变换把增广矩阵变为简化阶梯型矩阵</li></ul><p>算法步骤：</p><ol type="1"><li>找到当前列绝对值最大的一行</li><li>将该行与未确定阶梯型的顶行交换</li><li>对该行进行行变换使得非零首元素变为1</li><li>进行行变换使得下面所有行的当前列变成0</li><li>从下往上依次求解每个未知量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r,c;</span><br><span class="line">    <span class="comment">// 枚举每一列</span></span><br><span class="line">    <span class="keyword">for</span>(r=<span class="number">0</span>,c=<span class="number">0</span>;c&lt;n;++c)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=r;</span><br><span class="line"><span class="comment">// 1. 找出c这一列绝对值最大的数 所在的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&lt;n;++i)&#123;<span class="comment">// 这里i枚举的是行</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][c])&gt;<span class="built_in">abs</span>(a[t][c]))&#123;</span><br><span class="line">                t=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这一列上所有的数都是0的话 , 看下一列</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[t][c])&lt;eps)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 让第t行(首元素绝对值最大的那一行)与未固定的行(第r行)的第一行交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=n;++i) <span class="built_in">swap</span>(a[r][i],a[t][i]);</span><br><span class="line">        <span class="comment">// 3. 把这一行非零首元素变为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=c;--i) a[r][i]/=a[r][c];</span><br><span class="line">        <span class="comment">// 4. 将下面所有行的第c列(当前枚举列)变为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=r+<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][c])&gt;eps)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=c;--j)&#123;</span><br><span class="line">                    a[i][j]-=a[i][c]*a[r][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该行已固定，处理下一行</span></span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过r来观察方程解的数量</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][n])&gt;eps) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从下往上， 依次求出方程的解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">            a[i][n]-=a[j][n]*a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合数">组合数</h4><p><span class="math inline">\(C_n^m=\frac {n!}{m!(n-m)!}\)</span></p><p><span class="math inline">\(C_n^m=C_n^{n-m}\)</span></p><p><span class="math inline">\(C_n^m=C_{n-1}^{m-1}+C_{n-1}^m\)</span></p><p><span class="math inline">\(C_n^0+C_n^1+C_n^2+\cdots+C_n^n=2^n\)</span></p><h5 id="递推法-on2">递推法 <span class="math inline">\(O(n^2)\)</span></h5><ul><li><span class="math inline">\(C_n^m=C_{n-1}^{m-1}+C_{n-1}^m\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                c[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="预处理阶乘">预处理阶乘</h5><ul><li><p>用快速幂求逆元</p><p><span class="math inline">\(C_n^m=\frac {n!}{m!(n-m)!}=n!(m!)^{-1}(n-m)^{-1}\)</span></p></li><li><p>预处理 <span class="math inline">\(n!\;,\;(m!)^{-1}\;,\;(n-m)^{-1}\)</span></p></li><li><p><span class="math inline">\(O(NlogN)\)</span></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=<span class="number">1LL</span>*a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">factorial</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>]=infact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        fact[i]=<span class="number">1LL</span>*fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        infact[i]=<span class="number">1LL</span>*infact[i<span class="number">-1</span>]*<span class="built_in">binpow</span>(i,mod<span class="number">-2</span>,mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>*fact[n]*infact[m]%mod*infact[n-m]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lucas-定理">Lucas 定理</h5><ul><li><p><span class="math inline">\(C_n^m \equiv C_{n/p}^{m/p}C_{n\;\bmod\;p}^{m\;\bmod\;p}\;(\bmod\;p)\)</span></p></li><li><p>当问题规模很大，而模数是一个不大的质数的时候，就不能简单地通过递推求解来得到答案，需要用到 Lucas 定理，<span class="math inline">\(p\)</span> 一般在 <span class="math inline">\(10^5\)</span> 左右，模数 <span class="math inline">\(p\)</span> 必须为质数</p></li><li><p><span class="math inline">\(O(f(p)+g(n)\log n)\)</span> 其中 <span class="math inline">\(f(n)\)</span> 为预处理组合数的复杂度，<span class="math inline">\(g(n)\)</span> 为单次求组合数的复杂度</p></li><li><p><span class="math inline">\(C_{n}^{m}=\frac{n!}{(n-m) ! * m !}=\frac{n *(n-1) *(n-2) * \ldots *(n-m+1) *(n-m) * \ldots * 1}{(n-m) *(n-m-1) * \ldots * 1 * m !}=\frac{n *(n-1) *(n-2) * \ldots(n-m+1)}{m !}\)</span></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)res=res*a%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=<span class="number">1LL</span>*a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=a;i&lt;=b;++i,--j)&#123;</span><br><span class="line">        res=res*j%p*<span class="built_in">binpow</span>(i,p<span class="number">-2</span>,p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;p&amp;&amp;b&lt;p) <span class="keyword">return</span> <span class="built_in">C</span>(a,b,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>*<span class="built_in">C</span>(a%p,b%p,p)*<span class="built_in">Lucas</span>(a/p,b/p,p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="卡特兰数">卡特兰数</h4><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(H_0\)</span></th><th style="text-align: center;"><span class="math inline">\(H_1\)</span></th><th style="text-align: center;"><span class="math inline">\(H_2\)</span></th><th style="text-align: center;"><span class="math inline">\(H_3\)</span></th><th style="text-align: center;"><span class="math inline">\(H_4\)</span></th><th style="text-align: center;"><span class="math inline">\(H_5\)</span></th><th style="text-align: center;"><span class="math inline">\(H_6\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">14</td><td style="text-align: center;">42</td><td style="text-align: center;">132</td></tr></tbody></table><p><span class="math inline">\(H_n=\frac {4n-2}{n+1}H_{n-1}\;,\;H_0=1\)</span></p><p><span class="math inline">\(H_n=C_{2n}^n-C_{2n}^{n-1}=\frac {C_{2n}^n}{n+1}=\frac{(2n)!}{n!n!}=\frac{(2n)(2n-1)\cdots(n+1)}{n!}\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=<span class="number">1LL</span>*a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catalan</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i)res=res*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)res=res*<span class="built_in">binpow</span>(i,mod<span class="number">-2</span>,mod)%mod;</span><br><span class="line">    res=res*<span class="built_in">binpow</span>(n+<span class="number">1</span>,mod<span class="number">-2</span>,mod)%mod;  </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="路径计数问题">路径计数问题</h5><ul><li><p>非降路径是指只能向上或向右走的路径</p></li><li><p>从 <span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\((m,n)\)</span> 的非降路径数等于 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(y\)</span> 的排列数，即 <span class="math inline">\(C_{m+n}^m\)</span></p><p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251502810.png" /> <span class="math display">\[P(m,n)\rightarrow P(m+1,n-1)\]</span> 不穿过 <span class="math inline">\(y=x\)</span> 的路径条数：<span class="math inline">\(C_{m+n}^{n}-C_{m+n}^{n-1}\)</span> ，<span class="math inline">\(m=n\)</span> 时即卡特兰数 <span class="math inline">\(H_n=C_{2n}^n-C_{2n}^{n-1}\)</span></p></li></ul><h4 id="容斥原理">容斥原理</h4><p><span class="math display">\[\left|\bigcup_{i=1}^{n} S_{i}\right|=\sum_{m=1}^{n}(-1)^{m-1} \sum_{a_{i}&lt;a_{i+1}}\left|\bigcap_{i=1}^{m} S_{a_{i}}\right|\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1LL</span>*t*p[j]&gt;n)&#123;</span><br><span class="line">                t=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            ++s;</span><br><span class="line">            t*=p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s&amp;<span class="number">1</span>)res+=n/t;</span><br><span class="line">        <span class="keyword">else</span> res-=n/t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><h3 id="背包dp">背包DP</h3><blockquote><p>题意概要：有 <span class="math inline">\(N\)</span> 个物品和一个容量为 <span class="math inline">\(V\)</span> 的背包，每个物品有体积 <span class="math inline">\(v_i\)</span> 和价值 <span class="math inline">\(w_i\)</span> 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总体积不超过背包的体积</p></blockquote><h4 id="背包">0-1背包</h4><ul><li>已知条件有第 <span class="math inline">\(i\)</span> 个物品的体积 <span class="math inline">\(v_i\)</span> ，价值 <span class="math inline">\(w_i\)</span> ，以及背包的总容量 <span class="math inline">\(V\)</span>。设 DP 状态 <span class="math inline">\(f_{i,j}\)</span> 为在只能放前 <span class="math inline">\(i\)</span> 个物品的情况下，容量为 <span class="math inline">\(j\)</span> 的背包所能达到的最大总价值。</li></ul><p><strong>考虑转移</strong>：初始状态 <span class="math inline">\(f_{0,j}=0\)</span> ，假设当前已经处理好了前 <span class="math inline">\(i-1\)</span> 个物品的所有状态，那么对于第 <span class="math inline">\(i\)</span> 个物品：</p><ul><li><p>选择不加入第 <span class="math inline">\(i\)</span> 个物品，背包的剩余容量不变，背包中物品的总价值也不变，此时背包的价值为<span class="math inline">\(f_{i,j}=f_{i-1,j}\)</span></p></li><li><p>选择加入第 <span class="math inline">\(i\)</span> 个物品（若背包空间足够放下），背包的剩余容量会减小 <span class="math inline">\(v_i\)</span> ，背包中物品的总价值会增大 <span class="math inline">\(w_i\)</span> ，此时背包的价值为 <span class="math inline">\(f_{i,j}=f_{i-1,j-v_i}+w_i\)</span></p></li><li><p>故背包的最大价值为 <span class="math inline">\(f_{i,j}=\max(f_{i-1,j},f_{i-1,j-v_i}+w_i)\)</span></p></li></ul><p><strong>状态转移方程：</strong><span class="math inline">\(f_{i,j}=\max(f_{i-1,j},f_{i-1,j-v_i}+w_i)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">int</span> v[M],w[M];</span><br><span class="line"><span class="keyword">int</span> f[M][M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;++j)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>滚动数组优化：</strong>由于对 <span class="math inline">\(f_i\)</span> 有影响的只有 <span class="math inline">\(f_{i-1}\)</span> ，可以去掉第一维，直接用 <span class="math inline">\(f_j\)</span> 来表示处理到当前物品时背包容量为 <span class="math inline">\(j\)</span> 的最大价值，得出以下方程： <span class="math display">\[f_j=\max(f_j,f_{j-v_i}+w_i)\]</span></p><ul><li><span class="math inline">\(j\)</span> 应该倒序枚举，从 <span class="math inline">\(V\)</span> 枚举到 <span class="math inline">\(v_i\)</span></li><li>时间复杂度 <span class="math inline">\(O(NV)\)</span> ，空间复杂度 <span class="math inline">\(O(V)\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[V];</span><br></pre></td></tr></table></figure><h4 id="完全背包">完全背包</h4><blockquote><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p></blockquote><ul><li><p>朴素做法 暴力算法</p><ul><li>对于第 <span class="math inline">\(i\)</span> 件物品，枚举其选了多少个来转移</li><li>共求解 <span class="math inline">\(O(NV)\)</span> 个状态，求解状态 <span class="math inline">\(f_{i,j}\)</span> 的时间是 <span class="math inline">\(O(j/v_i)\)</span> ，时间复杂度 <span class="math inline">\(O(V\sum_{i=1}^N\frac{V}{v_i})\)</span></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251502022.jpeg" /> <span class="math display">\[f_{i, j}&amp;=&amp;\max _{k=0}^{\lfloor\frac{j}{v_i}\rfloor}\left(f_{i-1, j-k \times v_{i}}+w_{i} \times k\right)\\&amp;=&amp;\max(f_{i-1,j}\;,\;f_{i-1,j-v_i}+w_i\;,\;f_{i-1,j-2v_i}+2w_i\;,\;\cdots\;,\;f_{i-1,j-\lfloor\frac{j}{v_i}\rfloor v_i}+\lfloor\frac{j}{v_i}\rfloor w_i)\]</span></p></li><li><p>优化时间 <span class="math inline">\(O(NV)\)</span> <span class="math display">\[f_{i, j}&amp;=&amp;\max(f_{i-1,j}\;,\;f_{i-1,j-v_i}+w_i\;,\;f_{i-1,j-2v_i}+2w_i\;,\;\cdots\;,\;f_{i-1,j-\lfloor\frac{j}{v_i}\rfloor v_i}+\lfloor\frac{j}{v_i}\rfloor w_i)\\f_{i, j-v_i}&amp;=&amp;\max(f_{i-1,j-v_i}\;,\;f_{i-1,j-2v_i}+w_i\;,\;f_{i-1,j-3v_i}+2w_i\;,\;\cdots\;,\;f_{i-1,j-v_i-\lfloor\frac{j-v_i}{v_i}\rfloor v_i}+\lfloor\frac{j-v_i}{v_i}\rfloor w_i)\\&amp;=&amp;\max(f_{i-1,j-v_i}\;,\;f_{i-1,j-2v_i}+w_i\;,\;f_{i-1,j-3v_i}+2w_i\;,\;\cdots\;,\;f_{i-1,j-\lfloor\frac{j}{v_i}\rfloor v_i}+(\lfloor\frac{j}{v_i}\rfloor -1)w_i)\]</span> 则有 <span class="math display">\[f_{i, j}&amp;=&amp;\max _{k=0}^{\lfloor\frac{j}{v_i}\rfloor}\left(f_{i-1, j-k \times v_{i}}+w_{i} \times k\right)\\&amp;=&amp;\max(f_{i-1,j}\;,\;f_{i-1,j-v_i}+w_i\;,\;f_{i-1,j-2v_i}+2w_i\;,\;\cdots\;,\;f_{i-1,j-\lfloor\frac{j}{v_i}\rfloor v_i}+\lfloor\frac{j}{v_i}\rfloor w_i)\\&amp;=&amp;\max(f_{i-1,j}\;,\;\max(f_{i-1,j-v_i}+w_i\;,\;f_{i-1,j-2v_i}+2w_i\;,\;\cdots\;,\;f_{i-1,j-\lfloor\frac{j}{v_i}\rfloor v_i}+\lfloor\frac{j}{v_i}\rfloor w_i))\\\]</span> 即 <span class="math display">\[f_{i,j}=\max(f_{i-1,j}\;,\;f_{i,j-v_i}+w_i)\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> v[M],w[M];</span><br><span class="line"><span class="keyword">int</span> f[M][M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;++j)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>滚动数组优化空间到一维 <span class="math display">\[f_{j}=\max(f_{j},f_{j-v_i}+w_i)\\j\;\text{从小到大正向枚举}\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;++j)&#123;</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[V];</span><br></pre></td></tr></table></figure></li></ul><h4 id="多重背包">多重背包</h4><blockquote><p>多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 <span class="math inline">\(s_i\)</span> 个，而非一个。</p></blockquote><ul><li><p>朴素做法 <span class="math inline">\(O(V\sum_{i=1}^Ns_i)\)</span></p><p>把「每种物品选 <span class="math inline">\(s_i\)</span> 次」等价转换为「有 <span class="math inline">\(s_i\)</span> 个相同的物品，每个物品选一次」。</p><p>这样就转换成了一个 0-1 背包模型。</p><p>状态转移方程： <span class="math display">\[f_{i,j}&amp;=&amp;\max(f_{i-1,j}\;,\;f_{i-1,j-v_i}+w_i\;,\;f_{i-1,j-2v_i}+2w_i\;,\;\cdots\;,\;f_{i-1,j-s_iv_i}+s_iw_i)\\&amp;=&amp;\max_{k=0}^{s_i}(f_{i-1,j-kv_i}+kw_i)\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">int</span> v[M],w[M],s[M];</span><br><span class="line"><span class="keyword">int</span> f[M][M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;++k)&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二进制分组优化">二进制分组优化</h4><ul><li><p>利用二进制的思想, 我们把第 <span class="math inline">\(i\)</span> 种物品换成若干件物品, 使得原问题中第 <span class="math inline">\(i\)</span> 种物品可取的每种策略「取 <span class="math inline">\(0\cdots s_{i}\)</span> 件」均能等价于取若干件代换以后的物品。 另外, 取超过 <span class="math inline">\(s_{i}\)</span> 件的策略必不能出现。</p></li><li><p>方法是：将第 <span class="math inline">\(i\)</span> 种物品分成若干件 01 背包中的物品, 其中每件物品有一个系数。这件物品的费用和价值均是原来的费用和价值乘以这个系数。</p><ul><li><p>令这些系数分别为 <span class="math inline">\(1,2^1,2^{2}, \cdots ,2^{k-1}, s_{i}-2^{k}+1\)</span>, 且 <span class="math inline">\(k\)</span> 是满足 <span class="math inline">\(1+2^1+2^2+\cdots+2^{k-1}=2^{k}-1\leq s_{i}\)</span> 的最大整数，即 <span class="math inline">\(k=\lfloor \log_2(s_i+1) \rfloor\)</span> 。</p></li><li><p>分成的这几件物品的系数和为 <span class="math inline">\(s_{i}\)</span>, 表明不可能取多于 <span class="math inline">\(s_{i}\)</span> 件的第 <span class="math inline">\(i\)</span> 种物品。</p></li><li><p>另外 这种方法也能保证对于 <span class="math inline">\(0 \ldots s_{i}\)</span> 间的每一个整数，均可以用若干个系数的和表示。这里算法正确性的证明可以分 <span class="math inline">\(0 \ldots 2^{k-1}\)</span> 和 <span class="math inline">\(2^{k} \cdots s_{i}\)</span> 两段来分别讨论得出。</p></li></ul></li><li><p>这样就将第 <span class="math inline">\(i\)</span> 个物品分成了 <span class="math inline">\(O(\log{s_i})\)</span> 个物品，复杂度降为 <span class="math inline">\(O(V\sum_{i=1}^N\log{s_i})\)</span></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">int</span> v[M],w[M],idx;</span><br><span class="line"><span class="keyword">int</span> f[MM];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,s;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;s)&#123;</span><br><span class="line">            v[++idx]=k*a;</span><br><span class="line">            w[idx]=k*b;</span><br><span class="line">            s-=k;</span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s)&#123;</span><br><span class="line">            v[++idx]=s*a;</span><br><span class="line">            w[idx]=s*b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=idx;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];--j)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分组背包">分组背包</h4><blockquote><p>所谓分组背包，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251502297.png" alt="捕获.PNG" /><figcaption aria-hidden="true">捕获.PNG</figcaption></figure><ul><li>其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。</li><li>如何进行存储。用 <span class="math inline">\(v_{i,k}\;,\;w_{i,k}\)</span> 分别表示第 <span class="math inline">\(i\)</span> 组的第 <span class="math inline">\(k\)</span> 件物品的体积和价值，再用 <span class="math inline">\(s_i\)</span> 表示第 <span class="math inline">\(i\)</span> 组物品有多少个。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line"><span class="keyword">int</span> v[M][M],w[M][M],s[M];</span><br><span class="line"><span class="keyword">int</span> f[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s[i];++k)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][k]&gt;&gt;w[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s[i];++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k]) f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化细节">初始化细节</h4><ul><li>要求恰好装满背包,那么在初始化时除了 <span class="math inline">\(F[0]\)</span> 为 0，其它 <span class="math inline">\(F[1\cdots V]\)</span> 均设为 <span class="math inline">\(-\infty\)</span>，这样就可以保证最终得到的 <span class="math inline">\(F[V]\)</span> 是一种恰好装满背包的最优解。</li><li>如果并没有要求必须把背包装满, 而是只希望价格尽量大, 初始化时应该将 <span class="math inline">\(F[0][0\cdots V]\)</span> 全部设为 0 。</li><li>初始化的 <span class="math inline">\(F\)</span> 数组事实上就是在没有任何物品可以放入背包时的合法状态。<ul><li>如果要求背包恰好装满, 那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 <span class="math inline">\(-\infty\)</span> 了。</li><li>如果背包并非必须被装满，那么任何容量的背包，都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为 0 了。</li></ul></li></ul><h3 id="线性dp">线性DP</h3><h4 id="数字三角形">数字三角形</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N][N],a[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xc0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0xc0c0c0c0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) res=<span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长上升子序列">最长上升子序列</h4><p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251503530.jpeg" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251503652.jpeg" style="zoom: 33%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/zgzhengSEU/imagebed/Image/202110251503468.jpeg" alt="3.jpg" style="zoom:50%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N],a[N],path[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>||a[j]&lt;a[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i]&lt;f[j]+<span class="number">1</span>)&#123;</span><br><span class="line">                    f[i]=f[j]+<span class="number">1</span>;</span><br><span class="line">                    path[i]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;f[t]) t=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Length:&quot;</span>&lt;&lt;f[t]&lt;&lt;endl&lt;&lt;<span class="string">&quot;Path:&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        cout&lt;&lt;a[t]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        t=path[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,a[N],stk[N],tt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=tt+<span class="number">1</span>;<span class="comment">//扩大右边界至越界下标</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(stk[mid]&gt;=a[i])&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==tt+<span class="number">1</span>)stk[++tt]=a[i];<span class="comment">//越界，则不存在&gt;=a[i]的值</span></span><br><span class="line">        <span class="keyword">else</span> stk[r]=a[i];<span class="comment">//stk[r]为&gt;=a[i]的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;tt&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最短编辑距离">最短编辑距离</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a+<span class="number">1</span>&gt;&gt;m&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)f[<span class="number">0</span>][j]=j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i]!=b[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="零散知识点">零散知识点</h2><h3 id="模-1e97">模 <span class="math inline">\(1e9+7\)</span></h3><ul><li><span class="math inline">\(1e9+7\)</span> 是质数，且小于 2<sup>30</sup></li><li>如果原数是 <span class="math inline">\(int\)</span>，那么所有模过的数之间的加法操作必然不会溢出 <span class="math inline">\(int\)</span></li><li>如果原数是 <span class="math inline">\(long\;long\)</span>，那么所有模过的数两两相乘必然不会溢出 <span class="math inline">\(long\;long\)</span></li></ul><h3 id="无穷大无穷小">无穷大无穷小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nINF=<span class="number">0xc0c0c0c0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0xc0</span>,<span class="keyword">sizeof</span> b);</span><br></pre></td></tr></table></figure><h3 id="取整">取整</h3><ul><li>&gt;&gt;1等于÷2，是向下取整</li><li>/2是向0取整</li></ul><h3 id="调和级数">调和级数</h3><p><span class="math inline">\(\sum_{k=1}^n\frac{1}{k}=\ln{n}+C=O(\log{n})\)</span></p><h3 id="判断奇偶">判断奇偶</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x是奇数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x是偶数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="n"><span class="math inline">\(2^n\)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span> &lt;&lt; n;</span><br></pre></td></tr></table></figure><h3 id="位运算-1">位运算</h3><ul><li>&lt;&lt; &gt;&gt; 位移运算符优先级小于+-*/</li><li>数异或0等于自身，异或1...1等取反</li><li>将数n的第j位取反：n^(1&lt;&lt;j)</li><li>获取数n的第j位 n&gt;&gt;j&amp;1</li><li>返回n的最后一位1：lowbit(n) = n &amp; -n</li></ul><h3 id="listnode-小顶堆">ListNode* 小顶堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> ListNode* a, <span class="keyword">const</span> ListNode* b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; heap;</span><br></pre></td></tr></table></figure><h3 id="遍历转移">遍历转移</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (k &amp;&amp; nums[k - <span class="number">1</span>] &gt;= x) --k;</span><br><span class="line"><span class="keyword">while</span> (t + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[t + <span class="number">1</span>] &gt; x) ++t;</span><br></pre></td></tr></table></figure><h3 id="去重">去重</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> end = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="算法" scheme="https://zgzheng.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zgzheng.top/2021/10/18/hello-world/"/>
    <id>https://zgzheng.top/2021/10/18/hello-world/</id>
    <published>2021-10-18T09:55:58.607Z</published>
    <updated>2021-10-18T09:55:58.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
